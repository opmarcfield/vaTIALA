<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>OSRS Category Rankings</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    /* Set the page background to an image */
    body {
      margin: 0;
      padding: 0;
      /* URL of your image. Use a local image (e.g., "./bg.jpg") 
         or an external link (e.g., "https://example.com/bg.jpg") */
      background: url('background-image.png') no-repeat center center fixed;
      background-size: cover; 
      font-family: 'Poppins', sans-serif;
    }

    /* A container that holds everything in a centered box */
    .container {
      max-width: 900px;
      margin: 50px auto;
      background-color: #c1c2c4cc; /* Slightly transparent white (white w/0.8 opacity) */
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
    }

    h1, h2 {
      margin-top: 0;
      text-align: center;
    }

    p {
      text-align: center;
      font-size: 18px;
    }

    table {
      border-collapse: collapse;
      margin-bottom: 2em;
      width: 100%;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: left;
    }
    th {
      background-color: #efefef;
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>vaTIALA</h1>
    <p>Kategoriat Jagexin perus kategorioiden mukaan, combat/gathering/production/utility n√§ytt√§√§ <strong>XP GAINSSIT</strong> alkaen <strong>05/02/2025 16:50</strong>, cluet/minigamet/bossit n√§ytt√§√§ kokonais scoren. Bossit on bosseja :D minigamet on tempoross/wintertodt/gotr/zalcano, cluet on kaikki yhteenlaskettu!</p>
    <p>P√§ivitykset laitetaan menee keskell√§ y√∂t√§ kerran p√§iv√§ss√§ n√§in alkuun, katotaan toimiiko :D</p>
    <!-- Container to display results -->
    <div id="results"></div>
  </div>

  <script>
    // List of player JSON filenames (assuming they're all in ./data)
    const PLAYERS = ["vaOPA", "vaPEEXI", "vaRautaMake", "vaROSQIS"];

    async function fetchPlayerData(playerName) {
      const url = `./data/${playerName}.json`;  // e.g. ./data/vaPEEXI.json
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to load ${url}: ${response.status}`);
      }
      return response.json();  // returns the parsed JSON object
    }

    function calculateGains(snapshots) {
      // If there's only one snapshot, no "earliest" for a difference.
      // We'll just return 0 for the difference-based categories,
      // and the latest value for the "latest-only" categories.
      if (snapshots.length < 2) {
        const only = snapshots.length === 1 ? snapshots[0] : null;
        const cat = only ? only.custom_categories : {};
        return {
          // Difference-based categories -> 0
          Combat: 0,
          Gathering: 0,
          Production: 0,
          Utility: 0,
    
          // Latest-only categories -> just show snapshot's value (if any)
          Bosses: cat?.Bosses?.minigames_total_score ?? 0,
          Minigames: cat?.Minigames?.minigames_total_score ?? 0,
          Clues: cat?.Clues?.minigames_total_score ?? 0
        };
      }
    
      // Otherwise, we have earliest & latest
      const earliest = snapshots[0];
      const latest = snapshots[snapshots.length - 1];
    
      // Helper to safely get a skill XP difference
      function diffXP(categoryName) {
        const e = earliest.custom_categories[categoryName]?.skills_total_xp ?? 0;
        const l = latest.custom_categories[categoryName]?.skills_total_xp ?? 0;
        return l - e;
      }
    
      // For Bosses, Minigames, Clues, we show only the latest minigame score
      function latestScore(categoryName) {
        return latest.custom_categories[categoryName]?.minigames_total_score ?? 0;
      }
    
      return {
        // Show difference in XP for these categories
        Combat: diffXP("Combat"),
        Gathering: diffXP("Gathering"),
        Production: diffXP("Production"),
        Utility: diffXP("Utility"),
    
        // Show latest minigame score for these categories
        Bosses: latestScore("Bosses"),
        Minigames: latestScore("Minigames"),
        Clues: latestScore("Clues")
      };
    }
    

    function rankPlayersByCategory(playersData, category) {
      // Sort players in descending order of gains for the category
      return [...playersData].sort((a, b) => b.gains[category] - a.gains[category]);
    }

    async function main() {
      const playersData = [];

      for (const player of PLAYERS) {
        try {
          const data = await fetchPlayerData(player);
          // data has structure: { "player_name": ..., "snapshots": [...] }
          const gains = calculateGains(data.snapshots);
          playersData.push({
            name: data.player_name,
            gains
          });
        } catch (err) {
          console.error("Error fetching/parsing player:", player, err);
        }
      }

      const categories = ["Combat", "Gathering", "Production", "Utility", "Bosses", "Clues", "Minigames"];
      const diffCats = ["Combat", "Gathering", "Production", "Utility"];

      const container = document.getElementById("results");

      categories.forEach(category => {
        // Sort players by this category
        const ranking = rankPlayersByCategory(playersData, category);

        // Build an HTML heading
        const heading = document.createElement("h2");
        //XXXheading.textContent = `${category}`;
        if (diffCats.includes(category)) {
          heading.textContent = `${category} XP Gains`;
        } else {
          heading.textContent = `${category}`;
        }
        container.appendChild(heading);

        // Create a table for the ranks
        const table = document.createElement("table");
        table.innerHTML = `
          <thead>
            <tr>
              <th>Rank</th>
              <th>Player</th>
              <th>${diffCats.includes(category)
                ? `${category} XP Gains` 
                : `${category} Total`}</th>
            </tr>
          </thead>
        `;
        const tbody = document.createElement("tbody");

        ranking.forEach((p, index) => {
          const row = document.createElement("tr");
          let displayName = p.name; // Keep original name unchanged
        
          // Add titles only for the #1 ranked player
          if (index === 0) {
            row.style.fontWeight = "bold";
            let title = "";
        
            // Custom titles based on category
            if (category === "Clues") title = " üèÜ the CLUE MASTER";
            if (category === "Bosses") title = " üíÄ the BOSS KILLER";
            if (category === "Minigames") title = " üéÆ the MINIGAME CHAMP";
        
            // Append title to display name, but do NOT modify `p.name`
            displayName += title;
          }
        
          row.innerHTML = `
            <td>${index + 1}</td>
            <td>${displayName}</td>
            <td>${p.gains[category]}</td>
          `;
          tbody.appendChild(row);
        });

        table.appendChild(tbody);
        container.appendChild(table);
      });
    }

    main();
  </script>

</body>
</html>
